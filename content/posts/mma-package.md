---
type: posts
draft: false

title: "Modern package style of Mathematica"
subtitle: ""
date: 2018-11-03T18:00:00-06:00

authors:
  - me

preview:
  - "I came across a discussion on Stackexchange about the modern style of organizing code for Mathematica packages. This style is still *'undocumented and should be used at your own risk'*. But I've noticed more and more Mathematica internal packages start to use it. This new style improves the modularity compared with the old package style(, albeit not as good as those ones in python). This post is some notes about it."

tags:
  - Code
  - Mathematica

---
{{< oldpostflag >}}

I came across a [discussion](https://mathematica.stackexchange.com/questions/176434/declaring-package-with-dependencies-in-multiples-files/176489#176489)
on Stackexchange about the modern style of organizing code for Mathematica packages. This style is still *'undocumented and should be used at your own risk'*. But I've noticed more and more Mathematica internal packages start to use it. This new style improves the modularity compared with the old package style(, albeit not as good as those ones in python). This post is some notes about it.

Suppose the name of the package is {{< f MMAPackage  >}}. The file structure is pretty much the same:
{{< highlight plaintext >}}
[nc]MMAPackage
-- Kernel
   -- init.m
-- MMAPackage.m
-- Module1.m
-- Module2.m
-- ...
{{< /highlight >}}
First you should have a folder {{< f "/MMAPackage"  >}} with the same name as the package in the directory opened by
{{< highlight mathematica >}}
SystemOpen @ FileNameJoin[{$UserBaseDirectory, "Applications"}];
{{< /highlight >}}

## Modern style declaratives
### Package and PackageExport
A minimal example would be a single {{< f "MMAPackage.m"  >}} with the following content:
{{< highlight mathematica >}}
(* MMAPackage.m *)
Package["MMAPackage`"]

PackageExport["MySuperAdvancedFunction"]
MySuperAdvancedFunction[x_] := x + 1;
{{< /highlight >}}

Save this file (in the correct directory). Open another notebook and type:
{{< highlight mathematica >}}
<< MMAPackage`

MySuperAdvancedFunction[41]
(* 42 *)
{{< /highlight >}}

Perfect! Here {{< f Package  >}} opens the package context. And {{< f "PackageExport[\"func\"]" mma nolink >}} exposes the symbol {{< f "func"  >}} to the package user.

### PackageImport
It's a common case that we sometimes need to use functionalities from other packages inside our package. To do this, we can use {{< f "PackageImport" mma nolink >}}. In the following example, I need to use the {{< f EulerSum mma nolink >}} function from package {{< f "NumericalCalculus" mma nolink >}}.
{{< highlight mathematica "hl_lines=4">}}
(* MMAPackage.m *)
Package["MMAPackage`"]

PackageImport["NumericalCalculus`"]

PackageExport["MySuperAdvancedFunction2"]
MySuperAdvancedFunction2[a_, b_, dx_] := EulerSum[x ^ 2, {x, a, b, dx}];
{{< /highlight >}}

And the package user can use your function as usual:
{{< highlight mathematica >}}
<< MMAPackage`

MySuperAdvancedFunction2[1, 2, 0.1]
(* 413.296 *)
{{< /highlight >}}

### PackageScope
Before talking about this declarative, let's first understand the context generated by this packaging style. All exported symbols will be in the first level, e.g.
{{< highlight mathematica >}}
MMAPackage`exportedSymbol1
MMAPackage`exportedFunction2
{{< /highlight >}}

Any other symbols will be in a private context {{< f "PackagePrivate" mma nolink >}} of corresponding module file name:
{{< highlight mathematica >}}
MMAPackage`MMAPackage`PackagePrivate`symbol1
MMAPackage`MMAPackage`PackagePrivate`func2
MMAPackage`Module1`PackagePrivate`symbol3
MMAPackage`Module2`PackagePrivate`func4
{{< /highlight >}}

And using {{< f PackageScope mma nolink >}} can give us another context. {{< f "PackageScope[\"func\"]" mma nolink >}} will have the {{< f func  >}} setup in context
{{< highlight mathematica >}}
MMAPackage`PackageScope`func
{{< /highlight >}}

## About the {{< f "init.m"  >}} file
### Specify initialization order
The order of evaluating {{< f "*.m"  >}} file code files is alphabetical after the file with the package name being evaulated. Suppose we have the following {{< f "MMAPackage.m"  >}}, {{< f "Config.m"  >}} and {{< f "Parameters.m"  >}} files.
{{< highlight mathematica >}}
(* MMAPackage.m *)
Package["MMAPackage`"]

Print["MMAPackage.m loaded"]
{{< /highlight >}}
{{< highlight mathematica >}}
(* Parameters.m *)
Package["MMAPackage`"]

Print["Parameters.m loaded"]
{{< /highlight >}}
{{< highlight mathematica >}}
(* Config.m *)
Package["MMAPackage`"]

Print["Config.m loaded"]
{{< /highlight >}}

Loading the package will print:
{{< highlight mathematica >}}
MMAPackage.m loaded
Config.m loaded
Parameters.m loaded
{{< /highlight >}}

If we want to change the default order for some reason, we can make use of the {{< f "init.m"  >}} file. If there is such a file existing, it will have the highest priority during evaluation. Let's create this file under the {{< f "Kernel"  >}} directory.
{{< highlight mathematica >}}
(* init.m *)
$basePath = DirectoryName[$InputFileName, 2];

Get[FileNameJoin[{$basePath, "Parameters.m"}]]
Get[FileNameJoin[{$basePath, "Config.m"}]]
Get[FileNameJoin[{$basePath, "MMAPackage.m"}]]
{{< /highlight >}}

Now the it will print something like the following. Each file is loaded multiple times but the first three loads are in the order we specify.
{{< highlight mathematica >}}
Parameters.m loaded
Config.m loaded
MMAPackage.m loaded
Config.m loaded
MMAPackage.m loaded
Parameters.m loaded
MMAPackage.m loaded
Config.m loaded
Parameters.m loaded
{{< /highlight >}}

### Perform some global instructions
In this {{< f init.m  >}} file example, we perform some global instructions about the package. The first part checks the version of the Mathematica and abort the evaluation of the package if the required version is not met. Then it specifies a initialization order that we described in last section. In the end, it adds the {{< f Protect mma >}} attribute onto all the symbols inside the package.
{{< highlight mathematica >}}
(* Restrict the runnable version number of Mathematica *)
If[!OrderedQ[{11.0, 0}, {$VersionNumber, $ReleaseNumber}], 
  Print["MMAPackage requires Mathematica 11.0.0 or later."];
  Abort[]
]

Unprotect["MMAPackage`*", "MMAPackage`Private`*"];
(* Specify the initialization order *)
$basePath = DirectoryName[$InputFileName, 2];
Get[FileNameJoin[{$basePath, "Parameters.m"}]]
Get[FileNameJoin[{$basePath, "Config.m"}]]
Get[FileNameJoin[{$basePath, "MMAPackage.m"}]]

(* Protect the symbols used in the package *)
SetAttributes[
  Evaluate @ Flatten[Names /@ {"MMAPackage`*"}],
  {Protected, ReadProtected}
]
{{< /highlight >}}


## Caveat!
There are some important things to remember when using such style of packaging.
### DON'T put tailing semicolon (or anything else)
The parsing of such structure is done during runtime by a static code parser and apparently this parser is not yet very fault-tolerant. Things like tailing semicolon will break the parsing process and results in error. So DON'T do the following:
{{< highlight mathematica >}}
PackageExport["MMAPackage`"];
{{< /highlight >}}

### DON'T use {{< f Needs mma >}}
As just said, the static code parser won't recognize {{< f Needs mma >}}. If you want to import other packages, use {{< f PackageImport mma nolink >}}.

### Module file name should be valid context name
This basically means no whitespace or {{< f "_"  >}} are allowed.

### Need patch works in earlier than 11.0 version Mathematica
There are some context evaulation issues in earlies version of Mathematica. See [here](https://mathematica.stackexchange.com/questions/176434/declaring-package-with-dependencies-in-multiples-files/176489#176489) and [here](https://mathematica.stackexchange.com/questions/184711/what-to-be-aware-when-using-new-style-package) for more information.